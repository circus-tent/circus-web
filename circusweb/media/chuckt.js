/**
 * License: MIT
 * @see https://github.com/epixa/chuckt/blob/master/LICENSE.md
 * @version 0.2.0
 */

window.epixa || (window.epixa = {});

(function(){
  /**
   * Convenience method for applying chuckt event functionality to a socket
   *
   * IMPORTANT NOTE: Using this method will override any existing onmessage
   * callback on the given socket, so this should only be used if the only
   * messages you expect to receive through the socket are generated by a
   * chuckt server implementation.
   *
   * @param socket
   */
  epixa.chucktify = function(socket) {
    var chuckt = new ChuckT(socket);
    socket.onmessage = function(e) {
      chuckt.process(e.data);
    };
    return chuckt;
  };

  /**
   * Enables ChuckT event functionality on the given socket
   *
   * In terms of receiving responses from the backend, no assumptions are made.
   * Since the websocket API currently only supports a single onmessage
   * callback, the ChuckT client app is responsible for calling chuck.process()
   * when a message is received from the backend. Messages do not have to be
   * pre-filtered -- if chuckt.process() is called on a non-chuckt message, it
   * will simply be ignored.
   *
   * The only hard requirement of the given socket is that it implements a
   * send() method that takes in a single message string. It is assumed, but
   * not required, that the send() method will transport the encoded message to
   * the backend.
   *
   * @constructor
   */
  var ChuckT = epixa.ChuckT = function(socket) {
    this.socket = socket;
    this.callbacks = new Callbacks();
    this.listeners = {};
  };

  /**
   * Emits an event that proxies through the socket connection
   *
   * In addition to the name of the event to fire, you can pass any number of
   * arguments and they will be sent along with the event.
   *
   * If the last argument passed is a function, then it is registered as a
   * callback and is invoked whenever receipt is acknowledged on the backend.
   *
   * Usage:
   *  chuckt.emit('my-event', 'foo', 'bar');
   *  sends: {"chuckt":{"event":"my-event","args":["foo","bar"]}}
   *
   *  chuckt.emit('my-event', 'foo', console.log);
   *  sends: {"chuckt":{"event":"my-event","args":["foo","bar"],"callbackid":0}}
   *     and console.log() is called if the backend returns a callback response
   *
   * @param event
   */
  ChuckT.prototype.emit = function(event) {
    var data = { event: event };
    var args = Array.prototype.slice.call(arguments).slice(1);

    if (args.length > 0 && typeof args[args.length - 1] == 'function') {
      var callback = args.pop();
      data.callbackid = this.callbacks.register(callback);
    }

    if (args.length > 0) {
      data.args = args;
    }
    this.socket.send(this.serialize(data));
  };

  /**
   * Adds the given callback as a listener to the given event
   *
   * When an event is received from the backend, all of its listeners are fired
   * in order. Any arguments passed with the event will be passed to each
   * listener.
   *
   * @param event
   * @param callback
   */
  ChuckT.prototype.on = function(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  };

  /**
   * Removes event listeners
   *
   * If an event is specified, then only event listeners for that specific
   * event will be removed. If no event is specified, then all listeners
   * are removed.
   *
   * @param event
   */
  ChuckT.prototype.removeListeners = function(event) {
    if (typeof event === 'undefined') {
      this.listeners = {};
    } else {
      delete this.listeners[event];
    }
  };

  /**
   * Processes the given socket message
   *
   * Generally speaking, this method will be manually called from within the
   * socket's onmessage() callback.
   *
   * If the message is not a "chuckt" message, then it is ignored.
   *
   * If the message is a callback message, then the callback matching the
   * callbackid is invoked with any arguments that may also have been passed.
   *
   * If the message is an event message, then all listeners bound to that event
   * are fired in order with any arguments that may also have been passed.
   *
   * @param message
   */
  ChuckT.prototype.process = function(message) {
    var parsed = JSON.parse(message);
    // don't handle non-chuckt messages
    if (typeof parsed.chuckt !== 'object') return;
    var chuckt = parsed.chuckt;

    // message is a callback, so execute it
    if (typeof chuckt.callbackid !== 'undefined') {
      this.callbacks.use(chuckt.callbackid, chuckt.args);
      return;
    }

    // message is an emitted event, so execute all corresponding listeners
    if (typeof chuckt.event === 'string') {
      if (!this.listeners[chuckt.event]) return;
      for (var i in this.listeners[chuckt.event]) {
        this.listeners[chuckt.event][i].apply(this, chuckt.args);
      }
    }
  };

  /**
   * Serializes the given data as a json string with the chuckt prefix
   *
   * @param data
   * @return {*}
   */
  ChuckT.prototype.serialize = function(data) {
    return JSON.stringify({ chuckt: data });
  };

  /**
   * Callback collection
   *
   * Since callbacks are inherently volatile (once a registered callback is
   * fired, it is permanently deleted), some minor callback management is
   * necessary to minimize CPU and memory impact.
   *
   * @constructor
   */
  var Callbacks = function(){
    this.callbacks = [];
    this.max = -1;
  };

  /**
   * Registers the given callback and returns the callback's id
   *
   * @param callback
   * @return {*}
   */
  Callbacks.prototype.register = function(callback){
    this.callbacks[++this.max] = callback;
    return this.max;
  };

  /**
   * Invokes the callback identified by the callbackid with any arguments
   *
   * @param callbackid
   * @param args
   */
  Callbacks.prototype.use = function(callbackid, args){
    this.callbacks[callbackid].apply(this, args || {});
    delete this.callbacks[callbackid];
  };
})();
